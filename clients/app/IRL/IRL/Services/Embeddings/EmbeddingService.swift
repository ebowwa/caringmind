//
//  EmbeddingService.swift
//  irl
//
//  Created by Elijah Arbee on 9/18/24.
//

import Foundation
import CoreData

extension Array where Element == Double {
    func toFloatArray() -> [Float] {
        return self.map { Float($0) }
    }
}

class EmbeddingService {
    static let shared = EmbeddingService()
    
    private let persistenceController = PersistenceController.shared
    private let context: NSManagedObjectContext

    private init() {
        self.context = persistenceController.context
    }
    
    // Handles URL creation for embedding requests
    private func createURL(for model: String) throws -> URL {
        guard let url = URL(string: "\(Constants.API.baseURL)/embeddings/\(model)") else {
            throw URLError(.badURL)
        }
        return url
    }

    // Prepares the request for embedding
    private func prepareRequest(with text: String, url: URL) throws -> URLRequest {
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let body = ["input_text": text]
        request.httpBody = try JSONEncoder().encode(body)
        
        print("Sending request to: \(url)")
        print("Request body: \(String(data: request.httpBody!, encoding: .utf8) ?? "")")
        return request
    }

    // Validates the response from the server
    private func validateResponse(_ response: URLResponse) throws -> HTTPURLResponse {
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("Received response with status code: \(httpResponse.statusCode)")
        
        guard (200...299).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }
        
        return httpResponse
    }

    // Decodes the data from the response
    private func decodeResponse(from data: Data) throws -> EmbeddingResponse {
        return try JSONDecoder().decode(EmbeddingResponse.self, from: data)
    }

    // Main function to get embedding with optional model parameter
    func getEmbedding(for text: String, model: String = "small") async throws -> EmbeddingResponse {
        let url = try createURL(for: model)
        let request = try prepareRequest(with: text, url: url)
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        _ = try validateResponse(response)
        
        let decodedResponse = try decodeResponse(from: data)
        return decodedResponse
    }
    
    // MARK: - Knowledge Graph Management
    
    /// Creates a new key with the given name and embedding.
    func createKey(name: String, embedding: [Float]) throws -> KeyEntity {
        let key = KeyEntity(context: context)
        key.id = UUID()
        key.name = name
        
        // Convert [Float] to Data
        let embeddingData = try JSONEncoder().encode(embedding)
        key.embedding = embeddingData // Using Transformable with FloatArrayTransformer
        try context.save()
        return key
    }

    /// Creates a new relationship between two keys with the given type and embedding.
    func createRelationship(type: String, source: KeyEntity, target: KeyEntity, embedding: [Float]) throws -> RelationshipEntity {
        let relationship = RelationshipEntity(context: context)
        relationship.id = UUID()
        relationship.type = type
        relationship.source = source
        relationship.target = target
        
        // Convert [Float] to Data
        let embeddingData = try JSONEncoder().encode(embedding)
        relationship.embedding = embeddingData // Using Transformable with FloatArrayTransformer
        try context.save()
        return relationship
    }


    /// Fetches a key by its name.
    func fetchKey(byName name: String) -> KeyEntity? {
        let request: NSFetchRequest<KeyEntity> = KeyEntity.fetchRequest()
        request.predicate = NSPredicate(format: "name == %@", name)
        return try? context.fetch(request).first
    }

    /// Fetches all relationships for a given key.
    func fetchRelationships(for key: KeyEntity) -> [RelationshipEntity] {
        return Array(key.relationships)
    }

    /// Adds a key with embedding generated by the EmbeddingService.
    func addKeyWithEmbedding(name: String, model: String = "small") async throws -> KeyEntity {
        let embeddingResponse = try await getEmbedding(for: name, model: model)
        let floatEmbedding = embeddingResponse.embedding.toFloatArray()
        let key = try createKey(name: name, embedding: floatEmbedding)
        return key
    }

    /// Adds a relationship with embedding generated by the EmbeddingService.
    func addRelationshipWithEmbedding(type: String, source: KeyEntity, target: KeyEntity, model: String = "small") async throws -> RelationshipEntity {
        let combinedText = "\(source.name) \(type) \(target.name)"
        let embeddingResponse = try await getEmbedding(for: combinedText, model: model)
        let floatEmbedding = embeddingResponse.embedding.toFloatArray()
        let relationship = try createRelationship(type: type, source: source, target: target, embedding: floatEmbedding)
        return relationship
    }

    /// Fetches top N relevant keys based on cosine similarity.
    func fetchRelevantKeys(for embedding: [Float], topN: Int = 5) throws -> [KeyEntity] {
        let request: NSFetchRequest<KeyEntity> = KeyEntity.fetchRequest()
        let keys = try context.fetch(request)
        
        let sortedKeys = keys.sorted { key1, key2 in
            guard let embeddingData1 = key1.embedding,
                  let embeddingData2 = key2.embedding,
                  let embedding1 = try? JSONDecoder().decode([Float].self, from: embeddingData1),
                  let embedding2 = try? JSONDecoder().decode([Float].self, from: embeddingData2) else {
                return false
            }
            let sim1 = cosineSimilarity(embedding, embedding1)
            let sim2 = cosineSimilarity(embedding, embedding2)
            return sim1 > sim2
        }
        
        return Array(sortedKeys.prefix(topN))
    }

    // MARK: - Utility

    /// Calculates cosine similarity between two vectors.
    private func cosineSimilarity(_ vectorA: [Float], _ vectorB: [Float]) -> Float {
        let dotProduct = zip(vectorA, vectorB).map(*).reduce(0, +)
        let magnitudeA = sqrt(vectorA.map { $0 * $0 }.reduce(0, +))
        let magnitudeB = sqrt(vectorB.map { $0 * $0 }.reduce(0, +))
        return (magnitudeA * magnitudeB) == 0 ? 0 : dotProduct / (magnitudeA * magnitudeB)
    }
}
